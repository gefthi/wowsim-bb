<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>wowsim-bb - Config & Rotations</title>
  <style>
    :root {
      --bg: #0c111b;
      --panel: #111827;
      --panel-2: #0f172a;
      --stroke: #1f2937;
      --muted: #94a3b8;
      --accent: #7dd3fc;
      --accent-2: #f472b6;
      --text: #e2e8f0;
      --success: #34d399;
      --warning: #fbbf24;
      --shadow: 0 20px 60px rgba(0,0,0,0.45);
      --radius: 14px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 32px;
      background: radial-gradient(circle at 20% 20%, rgba(124, 58, 237, 0.12), transparent 32%), radial-gradient(circle at 80% 0%, rgba(14, 165, 233, 0.14), transparent 30%), var(--bg);
      color: var(--text);
      font-family: "Space Grotesk", "DM Sans", "Inter", "Segoe UI", system-ui, sans-serif;
      line-height: 1.5;
    }
    h1 { margin: 0; letter-spacing: -0.02em; }
    .page { max-width: 1280px; margin: 0 auto 64px; }
    .hero {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 20px;
    }
    .eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 4px;
    }
    .lede { margin: 6px 0 0; color: var(--muted); max-width: 640px; }
    .hero-actions { display: flex; gap: 12px; align-items: center; }
    .status { min-width: 180px; color: var(--muted); font-size: 14px; }
    .panel-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    .panel {
      background: linear-gradient(145deg, var(--panel), var(--panel-2));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
    }
    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      font-weight: 700;
      font-size: 15px;
      letter-spacing: -0.01em;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(125, 211, 252, 0.12);
      color: var(--accent);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    label {
      display: block;
      margin-bottom: 4px;
      color: var(--muted);
      font-size: 13px;
      letter-spacing: 0.01em;
    }
    .field { display: flex; flex-direction: column; gap: 6px; }
    .field-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px 12px;
      margin-bottom: 10px;
    }
    input, select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--stroke);
      background: #0b1220;
      color: var(--text);
      font-size: 14px;
      transition: border 0.15s, box-shadow 0.15s, transform 0.1s;
    }
    input:focus, select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(125, 211, 252, 0.15);
      transform: translateY(-1px);
    }
    button {
      background: linear-gradient(120deg, #22d3ee, #f472b6);
      color: #0b1220;
      border: none;
      padding: 12px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      letter-spacing: 0.01em;
      transition: transform 0.12s ease, box-shadow 0.12s ease;
      box-shadow: 0 14px 30px rgba(34, 211, 238, 0.25);
    }
    button:hover { transform: translateY(-1px) scale(1.01); }
    button:active { transform: translateY(0); }
    .ghost-btn {
      background: transparent;
      border: 1px solid var(--stroke);
      color: var(--text);
      box-shadow: none;
    }
    .runes {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: stretch;
    }
    .rune-pane {
      flex: 1 1 340px;
      min-width: 300px;
      max-width: 520px;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 10px;
      background: #0c1322;
    }
    .rune-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
      font-weight: 700;
      letter-spacing: 0.02em;
      font-size: 13px;
    }
    .rune-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 8px;
      width: 100%;
    }
    @media (min-width: 1200px) {
      .rune-pane {
        flex-basis: 45%;
      }
      .rune-grid {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }
    }
    @media (min-width: 1600px) {
      .rune-pane {
        flex-basis: 30%;
      }
      .rune-grid {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }
    }
    .rune-pill {
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 10px;
      background: #0f192d;
      border: 1px solid var(--stroke);
      cursor: pointer;
      transition: border 0.15s, transform 0.1s, box-shadow 0.15s;
    }
    .rune-pill:hover {
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.4);
    }
    .rune-pill input {
      width: auto;
      accent-color: var(--accent);
    }
    .rune-name { font-weight: 600; text-transform: capitalize; }
    .rune-pill[data-tooltip]:after {
      content: attr(data-tooltip);
      position: absolute;
      left: 12px;
      bottom: 105%;
      min-width: 180px;
      max-width: 260px;
      background: #0b1220;
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      opacity: 0;
      pointer-events: none;
      transform: translateY(6px);
      transition: opacity 0.12s ease, transform 0.12s ease;
      font-size: 12px;
      line-height: 1.4;
      z-index: 5;
    }
    .rune-pill:hover:after { opacity: 1; transform: translateY(0); }
    .count {
      color: var(--muted);
      font-size: 12px;
      letter-spacing: 0.04em;
    }
    .flex { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .actions { display: grid; gap: 12px; }
    .action-row { border: 1px solid var(--stroke); padding: 12px; border-radius: 12px; background: #0f172a; }
    .action-header { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .condition { margin-top: 8px; padding: 10px; background: #0b1220; border-radius: 10px; border: 1px solid var(--stroke); }
    .predicate { display: flex; gap: 6px; align-items: center; margin-bottom: 6px; flex-wrap: wrap; }
    .small { width: 120px; }
    .medium { width: 160px; }
    .tag { padding: 2px 6px; background: #334155; border-radius: 6px; font-size: 12px; }
    .divider { height: 1px; background: var(--stroke); margin: 12px 0; }
  </style>
</head>
<body>
  <div class="page">
    <header class="hero">
      <div>
        <p class="eyebrow">Simulator setup</p>
        <h1>Player Config</h1>
        <p class="lede">Tune stats, targets, and Mystic Enchants before you fire off a sim run.</p>
      </div>
      <div class="hero-actions">
        <button form="player-form" type="submit">Save player.yaml</button>
        <div id="status" class="status"></div>
      </div>
    </header>

    <form id="player-form">
      <div class="panel-grid">
        <section class="panel">
          <div class="panel-header">
            <span>Profile</span>
            <span class="badge">Character</span>
          </div>
          <div class="field">
            <label for="name">Name</label>
            <input id="name" name="name" type="text" />
          </div>
          <div class="field-row">
            <div class="field">
              <label for="level">Level</label>
              <input id="level" name="level" type="number" step="1" />
            </div>
            <div class="field">
              <label for="pet">Pet</label>
              <select id="pet" name="pet"></select>
            </div>
          </div>
          <div class="field">
            <label for="rotation">Rotation</label>
            <select id="rotation" name="rotation"></select>
          </div>
        </section>

        <section class="panel">
          <div class="panel-header">
            <span>Target</span>
            <span class="badge">Encounter</span>
          </div>
          <div class="field-row">
            <div class="field">
              <label for="target-type">Target Type</label>
              <select id="target-type" name="target-type">
                <option value="boss">Boss</option>
                <option value="equal_level">Equal Level</option>
              </select>
            </div>
            <div class="field">
              <label for="target-level">Target Level</label>
              <input id="target-level" name="target-level" type="number" step="1" />
            </div>
            <div class="field">
              <label for="target-coe">Target has Curse of the Elements</label>
              <div class="rune-pill" style="background:#0b1220;border-color:var(--stroke);">
                <input id="target-coe" type="checkbox" />
                <span>Pre-applied (skip casting)</span>
              </div>
            </div>
          </div>
          <div class="divider"></div>
          <div class="panel-header">
            <span>Simulation</span>
            <span class="badge">Runtime</span>
          </div>
          <div class="field-row">
            <div class="field">
              <label for="duration">Fight Duration (sec)</label>
              <input id="duration" name="duration" type="number" step="1" />
            </div>
            <div class="field">
              <label for="iterations">Iterations</label>
              <input id="iterations" name="iterations" type="number" step="1" />
            </div>
          </div>
        </section>

        <section class="panel">
          <div class="panel-header">
            <span>Stats</span>
            <span class="badge">Offense</span>
          </div>
          <div class="field-row">
            <div class="field">
              <label for="spell-power">Spell Power</label>
              <input id="spell-power" name="spell-power" type="number" step="0.1" />
            </div>
            <div class="field">
              <label for="crit">Crit %</label>
              <input id="crit" name="crit" type="number" step="0.01" />
            </div>
            <div class="field">
              <label for="haste">Haste %</label>
              <input id="haste" name="haste" type="number" step="0.01" />
            </div>
            <div class="field">
              <label for="hit">Hit %</label>
              <input id="hit" name="hit" type="number" step="0.01" />
            </div>
            <div class="field">
              <label for="spirit">Spirit</label>
              <input id="spirit" name="spirit" type="number" step="0.1" />
            </div>
            <div class="field">
              <label for="intellect">Intellect</label>
              <input id="intellect" name="intellect" type="number" step="0.1" />
            </div>
            <div class="field">
              <label for="max-mana">Max Mana</label>
              <input id="max-mana" name="max-mana" type="number" step="1" />
            </div>
          </div>
        </section>

        <section class="panel">
          <div class="panel-header">
            <span>Mystic Enchants</span>
            <span class="badge">Loadout</span>
          </div>
          <div id="runes" class="runes"></div>
        </section>
      </div>
    </form>

    <header class="hero" style="margin-top:32px;">
      <div>
        <p class="eyebrow">APL Editor</p>
        <h1>Rotation Editor</h1>
      </div>
    </header>
    <div class="panel">
      <div class="flex" style="margin-bottom:10px;">
        <label for="rotation-select">Rotation</label>
        <select id="rotation-select"></select>
        <button id="load-rotation" class="ghost-btn">Load</button>
        <label for="save-as">Save As</label>
        <input id="save-as" type="text" placeholder="destruction-new.yaml" class="medium" />
        <button id="save-rotation">Save Rotation</button>
        <div id="rotation-status"></div>
      </div>
      <div class="actions" id="actions"></div>
      <button id="add-action" class="ghost-btn" style="margin-top:12px;">Add Action</button>
    </div>
  </div>

  <script>
    const state = { options: null, player: null, rotations: [], rotation: null, identifiers: null };
    const runeDescriptions = {
      cataclysmic_burst: "Immolate ticks extend burst stacks; Destruction spells consume stacks for extra damage.",
      destruction_mastery: "Flat damage bonus to core Destruction spells.",
      agent_of_chaos: "Immolate ticks haste-scale; Chaos Bolt cooldown reduced with a direct hit penalty.",
      chaos_manifesting: "Chaos spells rotate fire/shadow empowerment windows.",
      guldans_chosen: "Periodic damage buff that keeps Backdraft charges intact.",
      heating_up: "Casting builds stacking haste/damage for a short window.",
      decisive_decimation: "Conflagrate grants a Soul Fire cast time reduction window.",
      dusk_till_dawn: "Stacks from Shadow/Fire nukes empower your next Shadowburn (auto-Corruption at 3).",
      endless_flames: "Extends Pyroclasm duration.",
      inner_flame: "Chance to gain a bonus crit/damage window on cast.",
      pure_shadow: "Shadow casts stack Shadow Bolt/Fury damage for 15s.",
      pyroclasmic_shadows: "Shadow Bolt gains crit while Pyroclasm is active.",
      unstable_void: "Shadowfury triggers Backdraft.",
      nightfall: "Corruption ticks can grant instant Shadow Bolt (Shadow Trance).",
      twilight_reaper: "Shadow Trance Shadow Bolt is free and leeches health.",
      cursed_shadows: "Curse of Agony ticks can empower your next Shadow Bolt (+dmg, -mana).",
      shadow_siphon: "Shadowburn deals more damage on execute targets.",
      glyph_of_life_tap: "Life Tap grants bonus spell power for 40s.",
      glyph_of_conflagrate: "Conflagrate no longer consumes Immolate.",
      glyph_of_chaos_bolt: "Chaos Bolt cooldown reduced.",
      glyph_of_incinerate: "Incinerate deals increased damage.",
      glyph_of_immolate: "Increases Immolate DoT damage.",
      demonic_aegis: "Convert Spirit into additional spell power.",
      suppression: "Increases spell hit chance.",
      improved_imp: "Improves your Imp's damage.",
    };

    async function loadData() {
      const res = await fetch('/api/player');
      if (!res.ok) {
        document.getElementById('status').textContent = 'Failed to load config';
        return;
      }
      const data = await res.json();
      state.options = data.options;
      state.player = data.player;
      populateForm();

      const ids = await fetch('/api/identifiers');
      state.identifiers = await ids.json();

      const rotList = await fetch('/api/rotations');
      state.rotations = await rotList.json();
      populateRotationSelect();
    }

    function populateForm() {
      const p = state.player;
      document.getElementById('name').value = p.Character.Name || '';
      document.getElementById('level').value = p.Character.Level || 0;

      const petSel = document.getElementById('pet');
      petSel.innerHTML = '';
      state.options.pets.forEach(pet => {
        const opt = document.createElement('option');
        opt.value = pet;
        opt.textContent = pet;
        petSel.appendChild(opt);
      });
      petSel.value = p.Pet.Summon || 'none';

      const rotSel = document.getElementById('rotation');
      rotSel.innerHTML = '';
      state.options.rotations.forEach(rot => {
        const opt = document.createElement('option');
        opt.value = rot;
        opt.textContent = rot;
        rotSel.appendChild(opt);
      });
      rotSel.value = p.Rotation || state.options.rotations[0];

      document.getElementById('target-type').value = p.Target.Type || 'boss';
      document.getElementById('target-level').value = p.Target.Level || 60;
      document.getElementById('target-coe').checked = !!p.Target.Debuffs?.CurseOfElements;

      document.getElementById('spell-power').value = p.Stats.SpellPower || 0;
      document.getElementById('crit').value = p.Stats.CritPercent || 0;
      document.getElementById('haste').value = p.Stats.HastePercent || 0;
      document.getElementById('hit').value = p.Stats.HitPercent || 0;
      document.getElementById('spirit').value = p.Stats.Spirit || 0;
      document.getElementById('intellect').value = p.Stats.Intellect || 0;
      document.getElementById('max-mana').value = p.Stats.MaxMana || 0;

      document.getElementById('duration').value = p.Simulation.DurationSeconds || 0;
      document.getElementById('iterations').value = p.Simulation.Iterations || 0;

      renderRunes(p.MysticEnchants);
    }

    function runeLabel(name) {
      return name.replace(/_/g, ' ');
    }

    function renderRunes(mystic) {
      const container = document.getElementById('runes');
      container.innerHTML = '';
      const rarities = ['legendary','epic','rare'];
      rarities.forEach(r => {
        const pane = document.createElement('div');
        pane.className = 'rune-pane';
        pane.dataset.rarity = r;
        const limitKey = r.charAt(0).toUpperCase() + r.slice(1);
        const equippedKey = limitKey;
        const limit = mystic.Limits[limitKey] || 0;
        const equipped = new Set((mystic.Equipped && mystic.Equipped[equippedKey]) || []);

        const head = document.createElement('div');
        head.className = 'rune-head';
        head.innerHTML = `<span>${r.toUpperCase()} (limit ${limit})</span><span class="count" data-count="${r}">${equipped.size}/${limit}</span>`;
        pane.appendChild(head);

        const grid = document.createElement('div');
        grid.className = 'rune-grid';

        (state.options.runes[r] || []).forEach(name => {
          const lbl = document.createElement('label');
          lbl.className = 'rune-pill';
          lbl.dataset.tooltip = runeDescriptions[name] || 'Mystic Enchant';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.value = name;
          cb.checked = equipped.has(name);
          cb.onchange = () => updateRuneCounts();
          const txt = document.createElement('span');
          txt.className = 'rune-name';
          txt.textContent = runeLabel(name);
          lbl.appendChild(cb);
          lbl.appendChild(txt);
          grid.appendChild(lbl);
        });
        pane.appendChild(grid);
        container.appendChild(pane);
      });
      updateRuneCounts();
    }

    function updateRuneCounts() {
      const rarities = ['legendary','epic','rare'];
      rarities.forEach(r => {
        const inputs = document.querySelectorAll(`#runes .rune-pane[data-rarity="${r}"] input[type=checkbox]`);
        let selected = 0;
        inputs.forEach(cb => { if (cb.checked) selected++; });
        const countEl = document.querySelector(`.count[data-count="${r}"]`);
        if (countEl) {
          countEl.textContent = `${selected}/${state.player?.MysticEnchants?.Limits?.[r.charAt(0).toUpperCase()+r.slice(1)] || 0}`;
        }
      });
    }

    function gatherRunes() {
      const rarities = ['legendary','epic','rare'];
      const equipped = {Legendary:[], Epic:[], Rare:[]};
      rarities.forEach(r => {
        const inputs = document.querySelectorAll(`#runes .rune-pane[data-rarity="${r}"] input[type=checkbox]`);
        inputs.forEach(cb => {
          if (cb.checked) {
            const key = r.charAt(0).toUpperCase() + r.slice(1);
            equipped[key].push(cb.value);
          }
        });
      });
      return equipped;
    }

    document.getElementById('player-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const status = document.getElementById('status');
      status.textContent = 'Saving...';

      const payload = {
        player: {
          Character: {
            Name: document.getElementById('name').value,
            Level: Number(document.getElementById('level').value),
          },
          Pet: { Summon: document.getElementById('pet').value },
          Stats: {
            SpellPower: Number(document.getElementById('spell-power').value),
            CritPercent: Number(document.getElementById('crit').value),
            HastePercent: Number(document.getElementById('haste').value),
            HitPercent: Number(document.getElementById('hit').value),
            Spirit: Number(document.getElementById('spirit').value),
            Intellect: Number(document.getElementById('intellect').value),
            MaxMana: Number(document.getElementById('max-mana').value),
          },
          Target: {
            Type: document.getElementById('target-type').value,
            Level: Number(document.getElementById('target-level').value),
            Debuffs: {
              CurseOfElements: document.getElementById('target-coe').checked,
            },
          },
          Rotation: document.getElementById('rotation').value,
          Simulation: {
            DurationSeconds: Number(document.getElementById('duration').value),
            Iterations: Number(document.getElementById('iterations').value),
          },
          MysticEnchants: {
            Limits: state.player.MysticEnchants.Limits,
            Equipped: gatherRunes(),
          },
        }
      };

      const res = await fetch('/api/player', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload),
      });
      if (res.ok) {
        status.textContent = 'Saved player.yaml';
      } else {
        const text = await res.text();
        status.textContent = 'Error: ' + text;
      }
    });

    loadData();

    // Rotation UI
    async function loadRotation(name) {
      const res = await fetch(`/api/rotations/${name}`);
      if (!res.ok) {
        document.getElementById('rotation-status').textContent = 'Failed to load rotation';
        return;
      }
      const data = await res.json();
      // Convert conditions into UI shape
      data.file.rotation = data.file.rotation.map(a => dtoActionToUi(a));
      state.rotation = data;
      document.getElementById('save-as').value = state.rotation.filename || name;
      renderActions();
    }

    function dtoActionToUi(a) {
      const act = {...a};
      if (a.when) {
        act.when = dtoConditionToUi(a.when);
      }
      if (a.steps) {
        act.steps = a.steps.map(dtoActionToUi);
      }
      return act;
    }

    function dtoConditionToUi(c) {
      if (!c) return null;
      if (c.type === 'all' || c.type === 'any') {
        return {type: c.type, predicates: (c.children||[]).map(dtoConditionToUi)};
      }
      if (c.type === 'not' && c.children && c.children.length) {
        return {type:'not', child: dtoConditionToUi(c.children[0])};
      }
      const pred = {type: c.type};
      if (c.buff) pred.buff = c.buff;
      if (c.debuff) pred.debuff = c.debuff;
      if (c.spell) pred.spell = c.spell;
      if (c.resource) pred.resource = c.resource;
      if (c.min_remaining_seconds != null) pred.min = c.min_remaining_seconds;
      if (c.max_remaining_seconds != null) pred.max = c.max_remaining_seconds;
      ['lt_seconds','lte_seconds','gt_seconds','gte_seconds','lt_charges','lte_charges','gt_charges','gte_charges'].forEach(key => {
        if (c[key] != null) {
          const short = key.replace('_seconds','').replace('_charges','');
          pred[short] = c[key];
        }
      });
      return pred;
    }

    function populateRotationSelect() {
      const sel = document.getElementById('rotation-select');
      sel.innerHTML = '';
      state.rotations.forEach(r => {
        const opt = document.createElement('option');
        opt.value = r;
        opt.textContent = r;
        sel.appendChild(opt);
      });
      const current = state.player?.Rotation || state.rotations[0];
      sel.value = current;
      loadRotation(current);
    }

    function renderActions() {
      const container = document.getElementById('actions');
      container.innerHTML = '';
      if (!state.rotation) return;
      state.rotation.file.rotation.forEach((act, idx) => {
        const row = document.createElement('div');
        row.className = 'action-row';

        const header = document.createElement('div');
        header.className = 'action-header';

        const actSel = document.createElement('select');
        ['cast_spell','wait','macro','use_item'].forEach(val => {
          const opt = document.createElement('option');
          opt.value = val;
          opt.textContent = val;
          actSel.appendChild(opt);
        });
        actSel.value = act.action || 'cast_spell';
        actSel.onchange = () => { act.action = actSel.value; renderActions(); };
        header.appendChild(actSel);

        if (act.action === 'cast_spell') {
          const spellSel = document.createElement('select');
          state.identifiers.spells.forEach(sp => {
            const opt = document.createElement('option'); opt.value = sp; opt.textContent = sp; spellSel.appendChild(opt);
          });
          spellSel.value = act.spell || state.identifiers.spells[0];
          spellSel.onchange = () => { act.spell = spellSel.value; };
          header.appendChild(spellSel);
        } else if (act.action === 'wait') {
          const dur = document.createElement('input'); dur.type='number'; dur.step='0.1'; dur.className='small'; dur.value = act.duration_seconds||0;
          dur.oninput = () => { act.duration_seconds = Number(dur.value); };
          header.appendChild(dur);
          header.appendChild(tag('sec'));
        }

        const del = document.createElement('button');
        del.textContent = 'Delete';
        del.onclick = () => { state.rotation.file.rotation.splice(idx,1); renderActions(); };
        header.appendChild(del);

        row.appendChild(header);

        const condDiv = document.createElement('div');
        condDiv.className = 'condition';
        renderConditionEditor(condDiv, act, () => renderActions());
        row.appendChild(condDiv);

        container.appendChild(row);
      });
    }

    function tag(text) {
      const span = document.createElement('span');
      span.className = 'tag';
      span.textContent = text;
      return span;
    }

    function renderConditionEditor(container, act, rerender) {
      const cond = act.when || { type: 'none', predicates: [] };
      container.innerHTML = '';

      const typeSel = document.createElement('select');
      ['none','all','any'].forEach(t => {
        const opt = document.createElement('option'); opt.value = t; opt.textContent = t.toUpperCase(); typeSel.appendChild(opt);
      });
      typeSel.value = cond.type || 'none';
      typeSel.onchange = () => {
        cond.type = typeSel.value;
        cond.predicates = [];
        act.when = cond.type === 'none' ? null : cond;
        rerender();
      };
      container.appendChild(typeSel);

      if (cond.type !== 'none') {
        (cond.predicates || []).forEach((pred, i) => {
          const row = document.createElement('div');
          row.className = 'predicate';

          const predSel = document.createElement('select');
          ['buff_active','debuff_active','dot_remaining','cooldown_ready','cooldown_remaining','resource_percent','charges','true','false','not'].forEach(t => {
            const opt = document.createElement('option'); opt.value = t; opt.textContent = t; predSel.appendChild(opt);
          });
          predSel.value = pred.type;
          predSel.onchange = () => { pred.type = predSel.value; pred.child = null; pred.buff=''; pred.debuff=''; pred.spell=''; pred.resource=''; pred.lt=null; pred.gt=null; pred.lte=null; pred.gte=null; rerender(); };
          row.appendChild(predSel);

          if (pred.type === 'buff_active' || pred.type === 'charges') {
            const sel = document.createElement('select');
            state.identifiers.buffs.forEach(b => { const o=document.createElement('option'); o.value=b; o.textContent=b; sel.appendChild(o); });
            sel.value = pred.buff || state.identifiers.buffs[0];
            sel.onchange = () => { pred.buff = sel.value; };
            row.appendChild(sel);
          }
          if (pred.type === 'debuff_active' || pred.type === 'dot_remaining') {
            const sel = document.createElement('select');
            state.identifiers.debuffs.forEach(b => { const o=document.createElement('option'); o.value=b; o.textContent=b; sel.appendChild(o); });
            sel.value = pred.debuff || pred.spell || state.identifiers.debuffs[0];
            sel.onchange = () => { pred.debuff = sel.value; pred.spell = sel.value; };
            row.appendChild(sel);
          }
          if (pred.type === 'cooldown_ready' || pred.type === 'cooldown_remaining') {
            const sel = document.createElement('select');
            state.identifiers.spells.forEach(s => { const o=document.createElement('option'); o.value=s; o.textContent=s; sel.appendChild(o); });
            sel.value = pred.spell || state.identifiers.spells[0];
            sel.onchange = () => { pred.spell = sel.value; };
            row.appendChild(sel);
          }
          if (pred.type === 'resource_percent') {
            const sel = document.createElement('select');
            state.identifiers.resources.forEach(r => { const o=document.createElement('option'); o.value=r; o.textContent=r; sel.appendChild(o); });
            sel.value = pred.resource || state.identifiers.resources[0];
            sel.onchange = () => { pred.resource = sel.value; };
            row.appendChild(sel);
          }

          const comparatorFields = ['lt','lte','gt','gte'];
          if (['dot_remaining','cooldown_remaining','resource_percent'].includes(pred.type)) {
            comparatorFields.forEach(cmp => {
              const input = document.createElement('input');
              input.type='number'; input.step='0.1'; input.className='small';
              input.placeholder = cmp;
              input.value = pred[cmp] ?? '';
              input.oninput = () => { pred[cmp] = input.value === '' ? null : Number(input.value); };
              row.appendChild(input);
            });
          }
          if (pred.type === 'charges') {
            comparatorFields.forEach(cmp => {
              const input = document.createElement('input');
              input.type='number'; input.step='1'; input.className='small';
              input.placeholder = cmp;
              input.value = pred[cmp] ?? '';
              input.oninput = () => { pred[cmp] = input.value === '' ? null : Number(input.value); };
              row.appendChild(input);
            });
          }
          if (pred.type === 'buff_active' || pred.type === 'debuff_active') {
            ['min','max'].forEach(key => {
              const input = document.createElement('input');
              input.type='number'; input.step='0.1'; input.className='small';
              input.placeholder = key === 'min' ? 'min_rem' : 'max_rem';
              input.value = pred[key] ?? '';
              input.oninput = () => { pred[key] = input.value === '' ? null : Number(input.value); };
              row.appendChild(input);
            });
          }

          if (pred.type === 'not') {
            if (!pred.child) pred.child = {type:'buff_active', buff: state.identifiers.buffs[0]};
            const childContainer = document.createElement('div');
            childContainer.className='predicate';
            const childSel = document.createElement('select');
            ['buff_active','debuff_active','dot_remaining','cooldown_ready','cooldown_remaining','resource_percent','charges','true','false'].forEach(t => {
              const opt=document.createElement('option'); opt.value=t; opt.textContent=t; childSel.appendChild(opt);
            });
            childSel.value = pred.child.type;
            childSel.onchange = ()=>{ pred.child.type=childSel.value; rerender(); };
            childContainer.appendChild(childSel);
            row.appendChild(childContainer);
          }

          const del = document.createElement('button');
          del.textContent = 'Remove';
          del.type='button';
          del.onclick = () => { cond.predicates.splice(i,1); rerender(); };
          row.appendChild(del);

          container.appendChild(row);
        });

        const addBtn = document.createElement('button');
        addBtn.type='button';
        addBtn.textContent='Add Condition';
        addBtn.onclick = () => {
          cond.predicates = cond.predicates || [];
          cond.predicates.push({type:'buff_active', buff: state.identifiers.buffs[0]});
          act.when = cond;
          rerender();
        };
        container.appendChild(addBtn);
      }

      act.when = cond.type === 'none' ? null : cond;
    }

    document.getElementById('load-rotation').addEventListener('click', () => {
      const name = document.getElementById('rotation-select').value;
      loadRotation(name);
    });

    document.getElementById('add-action').addEventListener('click', () => {
      if (!state.rotation) return;
      state.rotation.file.rotation.push({action:'cast_spell', spell: state.identifiers.spells[0], when: null});
      renderActions();
    });

    document.getElementById('save-rotation').addEventListener('click', async () => {
      if (!state.rotation) return;
      const filename = document.getElementById('save-as').value.trim() || state.rotation.filename;
      const payload = { ...state.rotation.file };
      // convert UI condition shape to DTO schema
      payload.rotation = state.rotation.file.rotation.map(a => uiActionToDto(a));
      const res = await fetch(`/api/rotations/${filename}`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload),
      });
      if (res.ok) {
        document.getElementById('rotation-status').textContent = 'Saved';
      } else {
        document.getElementById('rotation-status').textContent = 'Error saving';
      }
    });

    function uiActionToDto(act) {
      const dto = {
        action: act.action,
        spell: act.spell,
        item: act.item,
        duration_seconds: act.duration_seconds,
        tags: act.tags,
        steps: act.steps ? act.steps.map(s => uiActionToDto(s)) : [],
      };
      if (act.when) {
        dto.when = uiConditionToDto(act.when);
      }
      return dto;
    }

    function uiConditionToDto(cond) {
      if (!cond || cond.type === 'none') return null;
      if (cond.type === 'all' || cond.type === 'any') {
        return {
          type: cond.type,
          children: (cond.predicates || []).map(p => uiPredicateToDto(p)),
        };
      }
      return uiPredicateToDto(cond);
    }

    function uiPredicateToDto(p) {
      if (p.type === 'true' || p.type === 'false') return {type: p.type};
      if (p.type === 'not' && p.child) {
        return {type: 'not', children: [uiPredicateToDto(p.child)]};
      }
      const dto = {type: p.type};
      if (p.buff) dto.buff = p.buff;
      if (p.debuff) dto.debuff = p.debuff;
      if (p.spell) dto.spell = p.spell;
      if (p.resource) dto.resource = p.resource;
      if (p.min != null) dto.min_remaining_seconds = p.min;
      if (p.max != null) dto.max_remaining_seconds = p.max;
      ['lt','lte','gt','gte'].forEach(key => {
        if (p[key] != null) {
          dto[`${key}_seconds`] = p[key];
          if (p.type === 'charges') {
            dto[`${key}_charges`] = p[key];
          }
        }
      });
      return dto;
    }
  </script>
</body>
</html>
